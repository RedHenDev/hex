<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hex v0.5 - Dynamic Terrain</title>
    
    <!-- Load A-Frame first -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    
    <!-- Define our custom shader -->
    // VERTEX SHADER
// ------------------------------------------------------------
<script id="vertexShader" type="x-shader/x-vertex">
  // Instance attributes
  attribute vec3 instancePosition;
  attribute float instanceHeight;
  attribute vec3 instanceColor;
  
  // A-Frame specific uniforms
  uniform vec3 ambientLightColor;
  uniform vec3 directionalLightColor[5];
  uniform vec3 directionalLightDirection[5];
  
  varying vec3 vColor;
  varying float vHeight;
  varying vec3 vNormal;
  varying vec3 vViewPosition;
  
  // Add UV coordinates for border calculation
  varying vec2 vUv;
  
  void main() {
      vColor = instanceColor;
      vHeight = instanceHeight;
      vUv = uv;
      
      // Apply instance position and scale height
      vec3 transformed = position;
      transformed.y *= instanceHeight;
      
      // Properly transform normals when scaling is applied
      vec3 transformedNormal = normal;
      // Adjust normal to account for y-scaling
      if (abs(normal.y) > 0.0) {
          transformedNormal = normalize(vec3(normal.x, normal.y / instanceHeight, normal.z));
      }
      vNormal = normalMatrix * transformedNormal;
      
      // Apply instance position
      vec4 worldPosition = modelMatrix * vec4(transformed + instancePosition, 1.0);
      
      // Calculate view-space position for lighting
      vec4 viewPosition = viewMatrix * worldPosition;
      vViewPosition = viewPosition.xyz;
      
      // Standard vertex transformation
      gl_Position = projectionMatrix * viewPosition;
  }
</script>`

// FRAGMENT SHADER
// ------------------------------------------------------------
`<script id="fragmentShader" type="x-shader/x-fragment">
  // A-Frame specific uniforms
  uniform vec3 ambientLightColor;
  uniform vec3 directionalLightColor[5];
  uniform vec3 directionalLightDirection[5];
  
  varying vec3 vColor;
  varying float vHeight;
  varying vec3 vNormal;
  varying vec3 vViewPosition;
  varying vec2 vUv;
  
  // Define border properties
  const float borderWidth = 0.04; // Adjust to control border width
  
  void main() {
      // Ensure normal is normalized
      vec3 normal = normalize(vNormal);
      
      // Calculate lighting
      vec3 lighting = ambientLightColor;
      
      // Add directional light contribution - use view space
      for (int i = 0; i < 5; i++) {
          if (length(directionalLightColor[i]) > 0.0) {
              vec3 directionalVector = normalize(directionalLightDirection[i]);
              float directional = max(dot(normal, directionalVector), 0.0);
              lighting += directionalLightColor[i] * directional;
          }
      }
      
      // Apply lighting to color with a minimum amount to prevent total darkness
      vec3 finalColor = vColor * max(lighting, vec3(0.2));
      
      // Border calculation for hexagon cylinder
      // For top and bottom faces, use polar coordinates to create hexagon border
      if (abs(normal.y) > 0.5) {
          // We're on top or bottom face - create circular border
          // Convert UV from [0,1] to [-1,1] range
          vec2 centeredUv = 2.0 * vUv - 1.0;
          
          // Calculate distance from center
          float distFromCenter = length(centeredUv);
          
          // Create border at the edge
          if (distFromCenter > (1.0 - borderWidth * 2.0)) {
              finalColor = vec3(0.0); // Black border
          }
      } else {
          // We're on the side faces
          // Create border at top and bottom edges
          float verticalPos = vUv.y; // This will be 0 at bottom and 1 at top of cylinder
          
          if (verticalPos < borderWidth || verticalPos > (1.0 - borderWidth)) {
              finalColor = vec3(0.0); // Black border
          }
          
          // Also create border at the hexagon corners
          // For cylindrical sides, use the U coordinate to determine horizontal position
          float horizontalPos = vUv.x; // This is 0-1 around the cylinder
          
          // The cylinder has 6 sides, so we have 6 corners
          float cornerWidth = borderWidth * 1.5; // Make corner border slightly wider
          
          // Check if we're near a corner (each corner is 1/6 = 0.166 apart)
          for (int i = 0; i < 6; i++) {
              float cornerPos = float(i) / 6.0;
              float dist = abs(horizontalPos - cornerPos);
              
              // Wrap around for the last corner
              dist = min(dist, 1.0 - dist);
              
              if (dist < cornerWidth) {
                  finalColor = vec3(0.0); // Black border
                  break;
              }
          }
      }
      
      gl_FragColor = vec4(finalColor, 1.0);
  }

    </script>
</head>
<body>
    
    <a-scene>
        <!-- Camera positioned to view the terrain from above, with faster movement -->
        <a-entity id="subject" position="0 15 25" rotation="-20 0 0" 
                  camera look-controls wasd-controls="acceleration: 50"></a-entity>
        
        <!-- Lighting to make the terrain visible -->
        <a-entity light="type: ambient; color: #BBB"></a-entity>
        <a-entity light="type: directional; color: #FFF; intensity: 0.6" 
                  position="-0.5 1 1"></a-entity>
        
        <!-- Sky background -->
        <a-sky color="#87CEEB"></a-sky>
        
        <!-- Container for terrain chunks -->
        <a-entity id="terrain-container"></a-entity>
    </a-scene>
    
    <!-- Load scripts in the right order AFTER the scene definition -->
    <!-- 1. First load core terrain modules -->
    <script src="urizex.js"></script>
    <script src="improved-noise.js"></script>
    <script src="terrain-enhancer.js"></script>
    <script src="chunk-manager.js"></script>
    
    <!-- 2. Register the terrain-manager component -->
    <script>
        // Register the terrain-manager component that will handle dynamic chunks
        AFRAME.registerComponent('terrain-manager', {
            schema: {
                loadDistance: {type: 'number', default: 150},
                unloadDistance: {type: 'number', default: 200},
                heightOffset: {type: 'number', default: 2.0},
                followTerrain: {type: 'boolean', default: true},
                chunkSize: {type: 'number', default: 16}, // Size of each chunk in hex units
                hexSize: {type: 'number', default: 1.0}   // Size of each hexagon
            },
            
            init: function() {
                console.log("Terrain manager component initializing...");
                
                // Get subject entity and ensure it exists
                this.subject = document.querySelector('#subject');
                if (!this.subject) {
                    console.error('Element with id "subject" not found!');
                    return;
                }
                
                // Get subject's Three.js object
                this.subjectObj = this.subject.object3D;
                
                // Last known position for chunk update check
                this.lastX = 0;
                this.lastZ = 0;
                this.chunkManager = null;
                this.lastChunkX = null;
                this.lastChunkZ = null;
                
                // Wait for the scene to fully load
                this.el.sceneEl.addEventListener('loaded', this.onSceneLoaded.bind(this));
                
                console.log('Terrain manager initialized, waiting for scene to load...');
            },
            
            onSceneLoaded: function() {
                try {
                    console.log("Scene loaded, initializing terrain chunk manager...");
                    
                    // Use enhanced terrain with chunk manager (no legacy mode)
                    this.chunkManager = new TerrainChunkManager({
                        chunkSize: this.data.chunkSize,
                        hexSize: this.data.hexSize,
                        workerCount: 4,
                        maxConcurrentLoads: 8
                    });
                    
                    // Initialize terrain around starting position
                    const initialX = this.subjectObj.position.x;
                    const initialZ = this.subjectObj.position.z;
                    this.lastX = initialX;
                    this.lastZ = initialZ;
                    
                    // Calculate chunk position
                    const hexWidth = this.data.hexSize * Math.sqrt(3);
                    const hexHeight = this.data.hexSize * 1.5;
                    const chunkWorldSizeX = this.data.chunkSize * hexWidth;
                    const chunkWorldSizeZ = this.data.chunkSize * hexHeight;
                    
                    // Store initial chunk coordinates
                    this.lastChunkX = Math.floor(initialX / chunkWorldSizeX);
                    this.lastChunkZ = Math.floor(initialZ / chunkWorldSizeZ);
                    
                    // Initial terrain update
                    this.updateTerrain(initialX, initialZ);
                    
                    // Start update loop with throttling
                    this.tick = AFRAME.utils.throttleTick(this.tick, 100, this);
                    
                    // Create debug markers
                    this.createDebugMarkers();
                } catch (error) {
                    console.error("Failed to initialize terrain:", error);
                }
            },
            
            updateTerrain: function(x, z) {
                if (this.chunkManager) {
                    // Update chunks based on current position
                    this.chunkManager.updateChunksFromPosition(
                        x, z, 
                        this.data.loadDistance, 
                        this.data.unloadDistance
                    );
                }
            },
            
            tick: function() {
                try {
                    const x = this.subjectObj.position.x;
                    const z = this.subjectObj.position.z;
                    
                    // Calculate distance moved
                    const distX = x - this.lastX;
                    const distZ = z - this.lastZ;
                    const distance = Math.sqrt(distX * distX + distZ * distZ);
                    
                    // Calculate current chunk position
                    const hexWidth = this.data.hexSize * Math.sqrt(3);
                    const hexHeight = this.data.hexSize * 1.5;
                    const chunkWorldSizeX = this.data.chunkSize * hexWidth;
                    const chunkWorldSizeZ = this.data.chunkSize * hexHeight;
                    
                    const currentChunkX = Math.floor(x / chunkWorldSizeX);
                    const currentChunkZ = Math.floor(z / chunkWorldSizeZ);
                    
                    // Calculate position within current chunk
                    const posWithinChunkX = (x / chunkWorldSizeX) - currentChunkX;
                    const posWithinChunkZ = (z / chunkWorldSizeZ) - currentChunkZ;
                    
                    // Check if the player has moved to a new chunk or halfway across the current chunk
                    const chunkChanged = currentChunkX !== this.lastChunkX || currentChunkZ !== this.lastChunkZ;
                    const halfwayAcrossChunk = 
                        (posWithinChunkX > 0.5 && this.lastHalfX !== 1) || 
                        (posWithinChunkX <= 0.5 && this.lastHalfX !== 0) ||
                        (posWithinChunkZ > 0.5 && this.lastHalfZ !== 1) || 
                        (posWithinChunkZ <= 0.5 && this.lastHalfZ !== 0);
                    
                    // Remember which half of the chunk we're in
                    this.lastHalfX = posWithinChunkX > 0.5 ? 1 : 0;
                    this.lastHalfZ = posWithinChunkZ > 0.5 ? 1 : 0;
                    
                    // Update terrain if we've moved to a new chunk or halfway across
                    if (chunkChanged || halfwayAcrossChunk) {
                        // Log position change
                        if (Math.random() < 0.1) { // Limit logging to prevent spam
                            console.log(`Position: (${x.toFixed(1)}, ${this.subjectObj.position.y.toFixed(1)}, ${z.toFixed(1)})`);
                            console.log(`Chunk: (${currentChunkX}, ${currentChunkZ}), Within: (${posWithinChunkX.toFixed(2)}, ${posWithinChunkZ.toFixed(2)})`);
                        }
                        
                        // Update terrain
                        this.updateTerrain(x, z);
                        
                        // Update last chunk position
                        this.lastChunkX = currentChunkX;
                        this.lastChunkZ = currentChunkZ;
                    }
                    
                    // Update last known position
                    this.lastX = x;
                    this.lastZ = z;
                    
                    // Handle terrain following
                    if (this.data.followTerrain && typeof generateTerrainHeight === 'function') {
                        // Calculate terrain height at current position
                        const terrainHeight = generateTerrainHeight(x, z);
                        
                        // Add offset to keep above terrain
                        const targetHeight = terrainHeight + this.data.heightOffset;
                        
                        // Set the new height, but only if we're below the target height
                        if (this.subjectObj.position.y != targetHeight) {
                            this.subjectObj.position.y += (targetHeight-this.subjectObj.position.y)*0.42;
                        }
                    }
                } catch (error) {
                    console.error('Error in terrain-manager tick:', error);
                }
            },
            
            // Create debug markers for visualization
            createDebugMarkers: function() {
                try {
                    // Create a debug function for markers
                    const createMarker = function(id, color, size, x, z) {
                        // Check if marker already exists
                        const existing = document.getElementById(id);
                        if (existing && existing.parentNode) {
                            existing.parentNode.removeChild(existing);
                        }
                        
                        // Create marker entity
                        const marker = document.createElement('a-entity');
                        marker.id = id;
                        
                        // Add sphere
                        const sphere = document.createElement('a-sphere');
                        sphere.setAttribute('radius', size);
                        sphere.setAttribute('color', color);
                        sphere.setAttribute('material', 'emissive: ' + color + '; emissiveIntensity: 0.5');
                        marker.appendChild(sphere);
                        
                        // Add pole
                        const pole = document.createElement('a-cylinder');
                        pole.setAttribute('radius', size/5);
                        pole.setAttribute('height', '10');
                        pole.setAttribute('color', color);
                        pole.setAttribute('position', '0 -5 0');
                        marker.appendChild(pole);
                        
                        // Position at correct terrain height
                        const height = typeof generateTerrainHeight === 'function' ? 
                            generateTerrainHeight(x, z) + 1 : 5;
                        marker.setAttribute('position', `${x} ${height} ${z}`);
                        
                        // Add to scene
                        document.querySelector('a-scene').appendChild(marker);
                        return marker;
                    };
                    
                    // Create reference markers
                    createMarker('origin-marker', 'red', 0.7, 0, 0);
                    createMarker('x-marker', 'green', 0.7, 10, 0);
                    createMarker('z-marker', 'blue', 0.7, 0, 10);
                    createMarker('diag-marker', 'yellow', 0.7, 10, 10);
                    
                    // Create moving marker
                    const movingMarker = createMarker('moving-marker', 'magenta', 0.5, 5, 5);
                    
                    // Animate
                    let angle = 0;
                    function updateMovingMarker() {
                        if (typeof generateTerrainHeight === 'function') {
                            angle += 0.01;
                            const radius = 20;
                            const x = Math.sin(angle) * radius;
                            const z = Math.cos(angle) * radius;
                            const height = generateTerrainHeight(x, z);
                            movingMarker.setAttribute('position', `${x} ${height + 1} ${z}`);
                        }
                        requestAnimationFrame(updateMovingMarker);
                    }
                    updateMovingMarker();
                    
                    console.log("Added debug markers");
                } catch (error) {
                    console.error("Error creating debug markers:", error);
                }
            }
        });
    </script>
    
    <!-- 3. After registration, add the component to the scene -->
    <script>
        // Check dependencies and add the component to the scene
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM content loaded, checking for required classes...");
            
            // Check for required classes
            if (typeof TerrainGenerator === 'undefined') {
                console.error("ERROR: TerrainGenerator class is not defined. Check if urizex.js loaded correctly.");
            } else {
                console.log("TerrainGenerator class found ✓");
            }
            
            if (typeof EnhancedTerrainGenerator === 'undefined') {
                console.error("WARNING: EnhancedTerrainGenerator class is not defined. Check if improved-noise.js loaded correctly.");
            } else {
                console.log("EnhancedTerrainGenerator class found ✓");
            }
            
            if (typeof TerrainChunkManager === 'undefined') {
                console.error("ERROR: TerrainChunkManager class is not defined. Check if chunk-manager.js loaded correctly.");
            } else {
                console.log("TerrainChunkManager class found ✓");
            }
            
            // Add the component to the scene
            const scene = document.querySelector('a-scene');
            if (scene) {
                console.log("Adding terrain-manager component to scene...");
                scene.setAttribute('terrain-manager', '');
            } else {
                console.error("Scene element not found!");
            }
        });
    </script>
    
    <!-- 4. Debug info display -->
    <div id="debug-overlay" style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.5); color: white; padding: 10px; font-family: monospace; z-index: 100; pointer-events: none;">
        <div>Terrain v0.5 - Enhanced Dynamic Chunks</div>
        <div id="position-info">Position: (0, 0, 0)</div>
        <div id="chunk-info">Chunk: (0, 0)</div>
        <div id="height-info">Height: 0.0</div>
    </div>
    
    <!-- 5. Debug panel updater -->
    <script>
        // Update debug panel
        document.addEventListener('DOMContentLoaded', function() {
            const positionInfo = document.getElementById('position-info');
            const chunkInfo = document.getElementById('chunk-info');
            const heightInfo = document.getElementById('height-info');
            
            // Update every 200ms
            setInterval(function() {
                const subject = document.querySelector('#subject');
                if (subject) {
                    const pos = subject.object3D.position;
                    positionInfo.textContent = `Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`;
                    
                    // Calculate chunk position
                    const hexSize = 1.0;
                    const chunkSize = 16;
                    const hexWidth = hexSize * Math.sqrt(3);
                    const hexHeight = hexSize * 1.5;
                    const chunkWorldSizeX = chunkSize * hexWidth;
                    const chunkWorldSizeZ = chunkSize * hexHeight;
                    const chunkX = Math.floor(pos.x / chunkWorldSizeX);
                    const chunkZ = Math.floor(pos.z / chunkWorldSizeZ);
                    
                    chunkInfo.textContent = `Chunk: (${chunkX}, ${chunkZ})`;
                    
                    // Get terrain height at current position
                    if (typeof generateTerrainHeight === 'function') {
                        const height = generateTerrainHeight(pos.x, pos.z);
                        heightInfo.textContent = `Height: ${height.toFixed(1)}`;
                    }
                }
            }, 200);
        });
    </script>
</body>
</html>