<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hex v0.4 - noisy</title>
    
    <!-- Load A-Frame first -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    
    <!-- Define our custom shader -->
    <script id="vertexShader" type="x-shader/x-vertex">
        // Instance attributes
        attribute vec3 instancePosition;
        attribute float instanceHeight;
        attribute vec3 instanceColor;
        
        // A-Frame specific uniforms
        uniform vec3 ambientLightColor;
        uniform vec3 directionalLightColor[5];
        uniform vec3 directionalLightDirection[5];
        
        varying vec3 vColor;
        varying float vHeight;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        
        void main() {
            vColor = instanceColor;
            vHeight = instanceHeight;
            
            // Apply instance position and scale height
            vec3 transformed = position;
            transformed.y *= instanceHeight;
            
            // Properly transform normals when scaling is applied
            vec3 transformedNormal = normal;
            // Adjust normal to account for y-scaling
            if (abs(normal.y) > 0.0) {
                transformedNormal = normalize(vec3(normal.x, normal.y / instanceHeight, normal.z));
            }
            vNormal = normalMatrix * transformedNormal;
            
            // Apply instance position
            vec4 worldPosition = modelMatrix * vec4(transformed + instancePosition, 1.0);
            
            // Calculate view-space position for lighting
            vec4 viewPosition = viewMatrix * worldPosition;
            vViewPosition = viewPosition.xyz;
            
            // Standard vertex transformation
            gl_Position = projectionMatrix * viewPosition;
        }
    </script>
    
    <script id="fragmentShader" type="x-shader/x-fragment">
        // A-Frame specific uniforms
        uniform vec3 ambientLightColor;
        uniform vec3 directionalLightColor[5];
        uniform vec3 directionalLightDirection[5];
        
        varying vec3 vColor;
        varying float vHeight;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        
        void main() {
            // Ensure normal is normalized
            vec3 normal = normalize(vNormal);
            
            // Calculate lighting
            vec3 lighting = ambientLightColor;
            
            // Add directional light contribution - use view space
            for (int i = 0; i < 5; i++) {
                if (length(directionalLightColor[i]) > 0.0) {
                    vec3 directionalVector = normalize(directionalLightDirection[i]);
                    float directional = max(dot(normal, directionalVector), 0.0);
                    lighting += directionalLightColor[i] * directional;
                }
            }
            
            // Apply lighting to color with a minimum amount to prevent total darkness
            vec3 finalColor = vColor * max(lighting, vec3(0.2));
            
            // Final color with alpha
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>
</head>
<body>
    
    <a-scene>
        <!-- Camera positioned to view the terrain from above, with faster movement -->
        <a-entity id="subject" position="0 15 25" rotation="-20 0 0" 
                  camera look-controls wasd-controls="acceleration: 50"></a-entity>
        
        <!-- Lighting to make the terrain visible -->
        <a-entity light="type: ambient; color: #BBB"></a-entity>
        <a-entity light="type: directional; color: #FFF; intensity: 0.6" 
                  position="-0.5 1 1"></a-entity>
        
        <!-- Sky background -->
        <a-sky color="#87CEEB"></a-sky>
        
        <!-- Container for terrain chunks -->
        <a-entity id="terrain-container"></a-entity>
    </a-scene>
    
    <!-- Load scripts in the right order AFTER the scene definition -->
    <!-- 1. First load core terrain modules -->
    <script src="urizex.js"></script>
    <script src="improved-noise.js"></script>
    <script src="chunk-manager.js"></script>
    
    <!-- 2. Then add the terrain loader component AFTER all modules are loaded -->
    <script>
        // Make sure all required classes exist
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM content loaded, checking for required classes...");
            
            // Check for required classes
            if (typeof TerrainGenerator === 'undefined') {
                console.error("ERROR: TerrainGenerator class is not defined. Check if urizex.js loaded correctly.");
            } else {
                console.log("TerrainGenerator class found ✓");
            }
            
            if (typeof TerrainChunkManager === 'undefined') {
                console.error("ERROR: TerrainChunkManager class is not defined. Check if chunk-manager.js loaded correctly.");
            } else {
                console.log("TerrainChunkManager class found ✓");
            }
            
            // Register the terrain-loader component
            AFRAME.registerComponent('terrain-loader', {
                schema: {
                    loadDistance: {type: 'number', default: 150},
                    unloadDistance: {type: 'number', default: 200},
                    heightOffset: {type: 'number', default: 2.0},
                    followTerrain: {type: 'boolean', default: true}
                },
                
                init: function() {
                    console.log("Terrain loader component initializing...");
                    
                    // Wait for the scene to fully load
                    this.el.sceneEl.addEventListener('loaded', this.onSceneLoaded.bind(this));
                    
                    // Get subject entity and ensure it exists
                    this.subject = document.querySelector('#subject');
                    if (!this.subject) {
                        console.error('Element with id "subject" not found!');
                        return;
                    }
                    
                    // Get subject's Three.js object
                    this.subjectObj = this.subject.object3D;
                    
                    console.log('Terrain loader initialized, waiting for scene to load...');
                },
                
                onSceneLoaded: function() {
                    try {
                        console.log("Scene loaded, initializing terrain manager...");
                        
                        // Initialize terrain manager
                        this.terrainManager = new TerrainChunkManager({
                            chunkSize: 16,
                            hexSize: 1.0,
                            workerCount: 2, // Reduced from 4 to troubleshoot
                            maxConcurrentLoads: 4, // Reduced from 8 to troubleshoot
                            seed: 12345 // Fixed seed for debugging
                        });
                        
                        console.log('Terrain manager initialized successfully!');
                        
                        // Start update loop with throttling (500ms)
                        this.tick = AFRAME.utils.throttleTick(this.tick, 500, this);
                    } catch (error) {
                        console.error("Failed to initialize terrain manager:", error);
                    }
                },
                
                tick: function() {
                    if (!this.terrainManager) {
                        // Skip if terrain manager isn't ready
                        return;
                    }
                    
                    try {
                        // Get camera position
                        const cameraEl = this.el.sceneEl.camera.el;
                        const position = new THREE.Vector3();
                        cameraEl.object3D.getWorldPosition(position);
                        
                        // Debug log position occasionally
                        if (Math.random() < 0.05) { // 5% chance each tick
                            console.log(`Camera at (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
                        }
                        
                        // Update chunks based on camera position
                        this.terrainManager.updateChunksFromPosition(
                            position.x, position.z, 
                            this.data.loadDistance, 
                            this.data.unloadDistance
                        );
                        
                        // Get terrain height if the function exists
                        if (typeof generateTerrainHeight === 'function' && this.data.followTerrain) {
                            // Get current subject position
                            const x = this.subjectObj.position.x;
                            const z = this.subjectObj.position.z;
                            
                            // Calculate terrain height at current position
                            const terrainHeight = generateTerrainHeight(x, z);
                            
                            // Add offset to keep above terrain
                            const targetHeight = terrainHeight + this.data.heightOffset;
                            
                            // Set the new height, but only if we're below the target height
                            if (this.subjectObj.position.y < targetHeight) {
                                this.subjectObj.position.y = targetHeight;
                                console.log('hi mom!');
                            }
                        }
                    } catch (error) {
                        console.error('Error in terrain-loader tick:', error);
                    }
                }
            });
            
            // Add the component to the scene
            const scene = document.querySelector('a-scene');
            if (scene) {
                console.log("Adding terrain-loader component to scene...");
                scene.setAttribute('terrain-loader', '');
            } else {
                console.error("Scene element not found!");
            }
        });
    </script>
    
    <!-- 3. Finally add debug tools -->
    <script>
        // Debug function to check terrain functionality
        window.addEventListener('load', function() {
            console.log("=== DEBUG: Window loaded ===");
            
            // Wait a moment to ensure all systems are initialized
            setTimeout(function() {
                // Check if generateTerrainHeight is available
                if (typeof generateTerrainHeight === 'function') {
                    console.log("✅ generateTerrainHeight function is available");
                    
                    // Test the function
                    try {
                        const height = generateTerrainHeight(0, 0);
                        console.log(`Test height at (0,0): ${height}`);
                    } catch (error) {
                        console.error("Error testing generateTerrainHeight:", error);
                    }
                } else {
                    console.error("❌ generateTerrainHeight function is NOT available");
                }
                
                // Check for terrain container
                const container = document.getElementById('terrain-container');
                if (container) {
                    console.log("✅ Terrain container found:", container);
                    console.log("Children count:", container.childElementCount);
                } else {
                    console.error("❌ Terrain container not found!");
                }
                
                // Look for TerrainChunkManager instance
                const sceneEl = document.querySelector('a-scene');
                if (sceneEl && sceneEl.components && sceneEl.components['terrain-loader']) {
                    const manager = sceneEl.components['terrain-loader'].terrainManager;
                    if (manager) {
                        console.log("✅ TerrainChunkManager instance found:", manager);
                        console.log("Loaded chunks:", manager.loadedChunks.size);
                        console.log("Pending chunks:", manager.pendingChunks.size);
                    } else {
                        console.error("❌ TerrainChunkManager instance not found!");
                    }
                }
                
                console.log("=== END DEBUG ===");
            }, 3000); // Wait 3 seconds
        });
    </script>
</body>
</html>